/* automatically generated by rust-bindgen 0.59.2 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub type size_t = ::std::os::raw::c_ulonglong;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
extern "C" {
    #[doc = " @abstract Get the required scratch buffer size to compress using LZFSE."]
    pub fn lzfse_encode_scratch_size() -> size_t;
}
extern "C" {
    #[doc = " @abstract Compress a buffer using LZFSE."]
    #[doc = ""]
    #[doc = "  @param dst_buffer"]
    #[doc = "  Pointer to the first byte of the destination buffer."]
    #[doc = ""]
    #[doc = "  @param dst_size"]
    #[doc = "  Size of the destination buffer in bytes."]
    #[doc = ""]
    #[doc = "  @param src_buffer"]
    #[doc = "  Pointer to the first byte of the source buffer."]
    #[doc = ""]
    #[doc = "  @param src_size"]
    #[doc = "  Size of the source buffer in bytes."]
    #[doc = ""]
    #[doc = "  @param scratch_buffer"]
    #[doc = "  If non-NULL, a pointer to scratch space for the routine to use as workspace;"]
    #[doc = "  the routine may use up to lzfse_encode_scratch_size( ) bytes of workspace"]
    #[doc = "  during its operation, and will not perform any internal allocations. If"]
    #[doc = "  NULL, the routine may allocate its own memory to use during operation via"]
    #[doc = "  a single call to malloc( ), and will release it by calling free( ) prior"]
    #[doc = "  to returning. For most use, passing NULL is perfectly satisfactory, but if"]
    #[doc = "  you require strict control over allocation, you will want to pass an"]
    #[doc = "  explicit scratch buffer."]
    #[doc = ""]
    #[doc = "  @return"]
    #[doc = "  The number of bytes written to the destination buffer if the input is"]
    #[doc = "  successfully compressed. If the input cannot be compressed to fit into"]
    #[doc = "  the provided buffer, or an error occurs, zero is returned, and the"]
    #[doc = "  contents of dst_buffer are unspecified."]
    pub fn lzfse_encode_buffer(
        dst_buffer: *mut u8,
        dst_size: size_t,
        src_buffer: *const u8,
        src_size: size_t,
        scratch_buffer: *mut ::std::os::raw::c_void,
    ) -> size_t;
}
extern "C" {
    #[doc = " @abstract Get the required scratch buffer size to decompress using LZFSE."]
    pub fn lzfse_decode_scratch_size() -> size_t;
}
extern "C" {
    #[doc = " @abstract Decompress a buffer using LZFSE."]
    #[doc = ""]
    #[doc = "  @param dst_buffer"]
    #[doc = "  Pointer to the first byte of the destination buffer."]
    #[doc = ""]
    #[doc = "  @param dst_size"]
    #[doc = "  Size of the destination buffer in bytes."]
    #[doc = ""]
    #[doc = "  @param src_buffer"]
    #[doc = "  Pointer to the first byte of the source buffer."]
    #[doc = ""]
    #[doc = "  @param src_size"]
    #[doc = "  Size of the source buffer in bytes."]
    #[doc = ""]
    #[doc = "  @param scratch_buffer"]
    #[doc = "  If non-NULL, a pointer to scratch space for the routine to use as workspace;"]
    #[doc = "  the routine may use up to lzfse_decode_scratch_size( ) bytes of workspace"]
    #[doc = "  during its operation, and will not perform any internal allocations. If"]
    #[doc = "  NULL, the routine may allocate its own memory to use during operation via"]
    #[doc = "  a single call to malloc( ), and will release it by calling free( ) prior"]
    #[doc = "  to returning. For most use, passing NULL is perfectly satisfactory, but if"]
    #[doc = "  you require strict control over allocation, you will want to pass an"]
    #[doc = "  explicit scratch buffer."]
    #[doc = ""]
    #[doc = "  @return"]
    #[doc = "  The number of bytes written to the destination buffer if the input is"]
    #[doc = "  successfully decompressed. If there is not enough space in the destination"]
    #[doc = "  buffer to hold the entire expanded output, only the first dst_size bytes"]
    #[doc = "  will be written to the buffer and dst_size is returned. Note that this"]
    #[doc = "  behavior differs from that of lzfse_encode_buffer."]
    pub fn lzfse_decode_buffer(
        dst_buffer: *mut u8,
        dst_size: size_t,
        src_buffer: *const u8,
        src_size: size_t,
        scratch_buffer: *mut ::std::os::raw::c_void,
    ) -> size_t;
}
